<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.20.2" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Grundleborg&#39;s Cave</title>
  

  
  <link rel="stylesheet" href="https://grundleborg.github.io/css/poole.css">
  <link rel="stylesheet" href="https://grundleborg.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://grundleborg.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://grundleborg.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Grundleborg&#39;s Cave" />

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/tomorrow.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-30877098-2', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>

<body class="theme-base-0b ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://grundleborg.github.io/"><h1>Grundleborg&#39;s Cave</h1></a>
      <p class="lead">
       Ramblings about Software Development, Hardware Hacking, Cinema &amp; Trains. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://grundleborg.github.io/posts/mattermost-custom-slash-command-aws-lambda/">
        Custom Slash Commands in Mattermost with AWS Lambda and API Gateway
      </a>
    </h1>

    <span class="post-date">Thu, Aug 24, 2017</span>

    

<p><a href="https://about.mattermost.com/">Mattermost</a> comes with a number of built-in <a href="https://docs.mattermost.com/developer/slash-commands.html#built-in-commands">slash commands</a>, such as <code>/join</code> to join a channel, or <code>/away</code> to set your status to away. It also supports Slack-compatible <a href="https://docs.mattermost.com/developer/slash-commands.html#custom-slash-command">custom slash commands</a>. These offer a simple way to add custom commands that help to make your team&rsquo;s workflow fast, efficient and enjoyable.</p>

<p>Custom slash commands are actually very easy to build. You just need to set up an HTTP endpoint which will receive the command payload, processes it and respond with the message which will be posted. Then add the custom slash command to the server and point it at your HTTP endpoint and you are done.</p>

<p>The only inconvenient part of building a custom slash command is making the HTTP endpoint available. The obvious way to solve this is to set up a webserver somewhere to host it, but this is a lot of overhead for an endpoint which might only triggered a few times a day. However, this is somewhere where serverless execution environments like <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> really shine, making it simple to set up, without needing a web server, and costing a few fractions of nothing for a lightly used endpoint.</p>

<p><strong>In this post, we will walk through setting up a Mattermost Custom Slash Command hosted as an <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> function in combination with an <a href="https://aws.amazon.com/api-gateway/">AWS API Gateway</a> endpoint.</strong></p>

<p>The Lambda function we write is going to be written in Python 3, although you can use any of the other <a href="http://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html">supported languages</a> if you prefer. As an example, we&rsquo;re going to use the <code>/standup</code> command the Mattermost Core Team use to post our progress update in our channels each day. If you&rsquo;d like to see what this command looks like now, jump ahead to the [See it in Action] section below.</p>

<h2 id="setup-in-aws">Setup in AWS</h2>

<p>We&rsquo;ll start by setting up the Lambda function and API Gateway endpoint in AWS.</p>

<ol>
<li>Log in to the AWS console and go to the <em>Lambda</em> section, and click on <em>Create a Lambda function</em>.</li>
<li>On the <em>Select blueprint</em> page, click the <em>Author from Scratch</em> button.</li>
<li>On the next screen, select <em>API Gateway</em> as the trigger.</li>
<li>Fill in the new set of settings which appear:

<ul>
<li>Pick an API Name (e.g. <code>MattermostSlashCommands</code>)</li>
<li>You can leave the deployment stage as <code>prod</code>.</li>
<li>Select <em>Open</em> for the security. This means your API can be invoked over HTTP without any credentials.</li>
</ul></li>
<li>On the next page, fill in these settings too:

<ul>
<li>Provide a name for your function. We&rsquo;ll use <code>SlashStandup</code>.</li>
<li>Choose <em>Python 3.6</em> for the runtime.</li>
<li>Select <em>Edit code inline</em>.</li>
<li>For the function code, copy paste the code in the [Implementing our Slack Command] section.</li>
<li>For the Lambda Function Handler, create a new role from template, and give it a name, e.g. <em>runLambdaFunctionsRole</em>.</li>
<li>For RAM and Timeout, select <code>128mb</code> and <code>30s</code> respectively.</li>
</ul></li>
<li>Advance to the review page, and click <em>Create Function</em>.</li>
<li>On the success page, you should see the URL for your new API endpoint.</li>
</ol>

<h2 id="implementing-our-slack-command">Implementing our Slack Command</h2>

<p>The full Python 3.6 code for the <code>/standup</code> Custom Slash Command is as follows:</p>

<pre><code class="language-python">from datetime import datetime
from urllib.parse import parse_qsl

import json

def parse_input(data):
    parsed = parse_qsl(data, keep_blank_values=True)
    result = {}
    for item in parsed:
        result[item[0]] = item[1]
    return result

def lambda_handler(event, context):
    # Parse the request
    try:
        request_data = parse_input(event[&quot;body&quot;])
    except:
        return {
            &quot;statusCode&quot;: 400,
            &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
            &quot;body&quot;: &quot;{}&quot;,
        }

    # Check the token matches.
    if request_data.get(&quot;token&quot;, &quot;&quot;) != &quot;YOUR MATTERMOST SLASH COMMAND TOKEN&quot;:
        return {
            &quot;statusCode&quot;: 401,
            &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
            &quot;body&quot;: &quot;{}&quot;,
        }

    # Build the response message text.
    text = &quot;##### Status Update for {}\n\n{}\n\n#standup-{} #standup&quot;.format(
            datetime.strftime(datetime.now(), &quot;%A %-d %B %Y&quot;),
            request_data[&quot;text&quot;],
            datetime.strftime(datetime.now(), &quot;%Y%m%d&quot;),
    )
    
    # Build the response object.
    response = {
        &quot;response_type&quot;: &quot;in_channel&quot;,
        &quot;text&quot;: text,
    }

    # Return the response as JSON
    return {
        &quot;body&quot;: json.dumps(response),
        &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
        &quot;statusCode&quot;: 200,
    }


</code></pre>

<p>Let&rsquo;s go through this bit-by-bit, looking at how it works:</p>

<pre><code class="language-python">def parse_input(data):
    parsed = parse_qsl(data, keep_blank_values=True)
    result = {}
    for item in parsed:
        result[item[0]] = item[1]
    return result
</code></pre>

<p>The <code>parse_input()</code> function parses the form-encoded data sent by Mattermost in the POST body when it calls our API endpoint into a <code>dict</code> for easy access to the parameters that have been passed.</p>

<pre><code class="language-python">    # Parse the request
    try:
        request_data = parse_input(event[&quot;body&quot;])
    except:
        return {
            &quot;statusCode&quot;: 400,
            &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
            &quot;body&quot;: &quot;{}&quot;,
        }
</code></pre>

<p>Before we do anything else, we parse the payload we were sent by the Mattermost server. If this fails, we return a <em>HTTP Bad Request</em> response.</p>

<pre><code class="language-python">    # Check the token matches.
    if request_data.get(&quot;token&quot;, &quot;&quot;) != &quot;YOUR MATTERMOST SLASH COMMAND TOKEN&quot;:
        return {
            &quot;statusCode&quot;: 401,
            &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
            &quot;body&quot;: &quot;{}&quot;,
        }
</code></pre>

<p>Next, we check that the <code>token</code> parameter in the request payload matches the one we have hardcoded in the code. By hardcoding the token provided by Mattermost when setting up the custom slash command, we can ensure that our API endpoint rejects any requests that do not come from our Mattermost server, returning a <em>HTTP Unauthorized</em> response in this case.</p>

<pre><code class="language-python">    # Build the response message text.
    text = &quot;##### Status Update for {}\n\n{}\n\n#standup-{} #standup&quot;.format(
            datetime.strftime(datetime.now(), &quot;%A %-d %B %Y&quot;),
            request_data[&quot;text&quot;],
            datetime.strftime(datetime.now(), &quot;%Y%m%d&quot;),
    )
</code></pre>

<p>Now we have the payload of the request, and have ensured the request is coming from our Mattermost server, we can construct the text of the response message.</p>

<pre><code class="language-python">    # Build the response object.
    response = {
        &quot;response_type&quot;: &quot;in_channel&quot;,
        &quot;text&quot;: text,
    }

    # Return the response as JSON
    return {
        &quot;body&quot;: json.dumps(response),
        &quot;headers&quot;: {&quot;Content-Type&quot;: &quot;application/json&quot;},
        &quot;statusCode&quot;: 200,
    }
</code></pre>

<p>Finally, we build the response object to send back to the Mattermost server in the JSON format it expects, setting the <code>response_type</code> to <code>in_channel</code> so the message appears in the channel for everyone to see. Then we dump it to a string and return the response object for API Gateway to process and return to our Mattermost server.</p>

<h2 id="configuring-mattermost">Configuring Mattermost</h2>

<p>The final part of the process is to add a new Custom Slash Command in Mattermost. Depending on the policy settings on your Mattermost server, you might need to be a System or Team Administrator to do this.</p>

<ol>
<li>In the Mattermost web app main menu, select <em>Integrations</em>, then <em>Slash Command</em> then <em>Add Slash Command</em>.</li>
<li>Fill in the form as per the screenshot below (making any changes you would like). The most important are:

<ul>
<li>The <em>Command Trigger Word</em> which dictates what <code>/word</code> you use to trigger invoke the slash command.</li>
<li>The <em>Request URL</em>, which should be the URL for the API endpoint on AWS API Gateway/Lambda we created earlier.</li>
<li>The <em>Request Method</em>, which should be <code>POST</code>.
<br /></li>
</ul></li>
</ol>

<p><img src="/img/slash_command_mattermost_config.png" alt="Custom Slash Command Configuration Screenshot" /></p>

<p>Once that form is filled in, click <em>Add</em> and you you will see the Token for the slash command. Use this in the Lambda function code described earlier to ensure that only <em>your</em> Mattermost server can call the lambda function.</p>

<h2 id="see-it-in-action">See it in Action</h2>

<p>We&rsquo;ve built the Slash command on AWS, and added it in Mattermost. Now all that remains is to try it out.</p>

<p>Start by typing <code>/standup</code> into the message box of Mattermost:</p>

<p><img src="/img/slash_command_mattermost_autocomplete.png" alt="Screenshot of custom slash command being autocompleted" /></p>

<p>Finish typing the command name, or click on the autocomplete suggestion to finish it for you. Then type in the rest of your status update:</p>

<p><img src="/img/slash_command_mattermost_typed.png" alt="Screenshot of composing a custom slash command" /></p>

<p>When you are done, press return, and if everything is set up correctly, you&rsquo;ll see your status update post appear in the channel:</p>

<p><img src="/img/slash_command_mattermost_posted.png" alt="Screenshot of a post generated by a custom slash command" /></p>

<p>And that&rsquo;s it really. You can customise the slash command to do whatever you want by changing this code. You can see a list of parameters that are sent by the Mattermost server when calling your API endpoint as well as a list of parameters it accepts in the response for more inspiration in the <a href="https://docs.mattermost.com/developer/slash-commands.html#custom-slash-command">Mattermost custom slash command documentation</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://grundleborg.github.io/posts/react-component-testing-in-mattermost/">
        React Component Testing in Mattermost
      </a>
    </h1>

    <span class="post-date">Tue, May 2, 2017</span>

    

<p><a href="https://github.com/mattermost/platform/">Mattermost</a> is a large web app written in <a href="https://facebook.github.io/react/">ReactJS</a>. It currently consists of a little over 300 components, built using a &ldquo;Flux-like&rdquo; architecture. This makes unit testing of components particularly challenging as the vast majority of them call methods on the stores directly. Of course, it&rsquo;s <em>possible</em> to mock out the stores in every
  test, but it&rsquo;s not really <em>practical</em> to do this.</p>

<p>If that was the end of the story, it would be a very boring one indeed. Fortunately, we are in the process of changing the underlying architecture of the Mattermost web app. After testing out <a href="http://redux.js.org/docs/introduction/">Redux</a> as the core of our new <a href="https://facebook.github.io/react-native/">React Native</a> powered <a href="https://github.com/mattermost/mattermost-mobile">mobile apps</a>, we&rsquo;ve decided to move over to the same architecture in our web app. I&rsquo;ll leave writing about the details of how that migration is happening to someone else, and instead focus on the impact of this on component testing.</p>

<p>As part of the transition to Redux, our component structure is changing. Instead of accessing stores from any component whenever some store data is needed, components will now be logically grouped into hierarchies of pure, UI components, receiving all their data through their <code>props</code>, with store access limited to a single &ldquo;controller&rdquo; UI-less component acting as the parent to each group of UI components.</p>

<p>This change of architecture brings a major benefit for component testing: UI components no longer have complicated side effects, extensive dependency chains, or direct access to data sources. Instead, there is a single API onto each component, described by its <code>props</code> field. This makes unit testing each component in isolation a trivial task.</p>

<p>From the point of view of the application as a whole, having well defined API contracts that are extensively unit tested eases the reuse of components (and reduces the appeal of copy-paste code blocks being littered throughout the code base  - something that currently happens rather more often than we&rsquo;d ideally like). It also provides a structure and set of expectations around the behaviour of components, which reduces the need to examine the internals of every child component (and grandchild&hellip;ad infinitum) to investigate bugs or make simple feature changes to a component, as is often the case in our current code base.</p>

<h2 id="jest-and-enzyme">Jest and Enzyme</h2>

<p>Mattermost uses <a href="https://facebook.github.io/jest/">Jest</a> to run the web app tests, in combination with <a href="http://airbnb.io/enzyme/">Enzyme</a>. The combination of these two utilities gives us a very simple workflow for component testing. Enzyme allows us to render and interact with React components in isolation, and Jest allows us to perform snapshot testing against these components - allowing us to detect any changes in rendered output of components and, where such a change is intended, automatically update the test snapshots. The integration between these two utilities is provided by the <a href="https://www.npmjs.com/package/enzyme-to-json">enzyme-to-json</a> library.</p>

<p>I won&rsquo;t get into the details of how we set up the plumbing for these libraries - plenty of other people have written about it (e.g. <a href="https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f">here</a>), and the only differences between what they and I have done are specific to the Mattermost codebase. If you are interested, you can have a look through the <a href="https://github.com/mattermost/platform/tree/master/webapp">Mattermost web app</a> source code.</p>

<h2 id="the-tests">The Tests</h2>

<p>To recap for a moment: the purpose of the component tests we are building is to verify the API contract of the UI components, expressed in terms of their <code>props</code>. However, since we don&rsquo;t yet live in a perfect world of 100% pure components, where practical we also want to test any known side-effects of global state on them.</p>

<p>Let&rsquo;s consider two example components. The first is the <code>BackstageHeader</code> component (full source code <a href="https://github.com/mattermost/platform/blob/v3.8.2/webapp/components/backstage/components/backstage_header.jsx">here</a>), chosen for its extreme simplicity, and the fact it is already a pure component. The render method is shown here:</p>

<pre><code class="language-javascript">render() {
    const children = [];

    React.Children.forEach(this.props.children, (child, index) =&gt; {
        if (index !== 0) {
            children.push(
                &lt;span
                    key={'divider' + index}
                    className='backstage-header__divider'
                &gt;
                    &lt;i className='fa fa-angle-right'/&gt;
                &lt;/span&gt;
            );
        }

        children.push(child);
    });

    return (
        &lt;div className='backstage-header'&gt;
            &lt;h1&gt;
                {children}
            &lt;/h1&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>And the props:</p>

<pre><code class="language-javascript">static get propTypes() {
    return {
        children: React.PropTypes.node
    };
}
</code></pre>

<p>This is a very simple component - it just builds a header based on the single, optional <code>children</code> prop, containing a list of child objects to insert into the header.</p>

<h3 id="shallow-rendering">Shallow Rendering</h3>

<p>The component tests we are building are <em>unit</em> tests, so we would like to limit the testing to individual components, and avoid changes in components elsewhere in the hierarchy affecting these tests. Enzyme provides a very useful tool for this: shallow rendering. Shallow rendering allows us to render just this component, but not any of it&rsquo;s child components, allowing it to be tested entirely in isolation.</p>

<pre><code class="language-javascript">test('should match snapshot without children', () =&gt; {
    const wrapper = shallow(
        &lt;BackstageHeader/&gt;
    );
    expect(wrapper).toMatchSnapshot();
});
</code></pre>

<p>This first, very simple test shallow-renders the <code>BackstageHeader</code> component, and makes use of Jest&rsquo;s built in snapshot testing capability to compare the rendered component with a known-good snapshot (more on that in the next section). As the <code>children</code> prop is optional, we test the component initially without any children to ensure it behaves properly.</p>

<p>The only other test we need here is one <em>with</em> the <code>children</code> prop set:</p>

<pre><code class="language-javascript">test('should match snapshot with children', () =&gt; {
    const wrapper = shallow(
        &lt;BackstageHeader&gt;
            &lt;div&gt;{'Child 1'}&lt;/div&gt;
            &lt;div&gt;{'Child 2'}&lt;/div&gt;
        &lt;/BackstageHeader&gt;
    );
    expect(wrapper).toMatchSnapshot();
});
</code></pre>

<p>That&rsquo;s it for this very simple component. You can see the <code>BackstageHeader</code> test suite in full <a href="https://github.com/mattermost/platform/blob/v3.8.2/webapp/tests/components/backstage/components/backstage_header.test.jsx">here</a>.</p>

<h3 id="running-tests">Running Tests</h3>

<p>If you are adding or modifying existing component tests, you can run jest in &ldquo;watch&rdquo; mode like this:</p>

<pre><code class="language-bash">user@host webapp$ npm run test:watch
</code></pre>

<p>This will run all tests that have been modified, and then continue to watch for further modifications, re-running tests as necessary. On the first run with new tests, it&rsquo;ll generate the test snapshots, placing them in the <code>__snapshots__</code> directory inside the directory where the test suite is located. You&rsquo;ll then see output like this:</p>

<pre><code>No tests found related to files changed since last commit.
Press `a` to run all tests, or run Jest with `--watchAll`.

Watch Usage
 › Press a to run all tests.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.

</code></pre>

<p>For the <code>BackstageHeader</code> test, let&rsquo;s take a look at the snapshot that has been generated:</p>

<pre><code class="language-javascript">// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`components/backstage/components/BackstageHeader should match snapshot with children 1`] = `
&lt;div
  className=&quot;backstage-header&quot;
&gt;
  &lt;h1&gt;
    &lt;div&gt;
      Child 1
    &lt;/div&gt;
    &lt;span
      className=&quot;backstage-header__divider&quot;
    &gt;
      &lt;i
        className=&quot;fa fa-angle-right&quot;
      /&gt;
    &lt;/span&gt;
    &lt;div&gt;
      Child 2
    &lt;/div&gt;
  &lt;/h1&gt;
&lt;/div&gt;
`;

exports[`components/backstage/components/BackstageHeader should match snapshot without children 1`] = `
&lt;div
  className=&quot;backstage-header&quot;
&gt;
  &lt;h1 /&gt;
&lt;/div&gt;
`;
</code></pre>

<p>We can see that this contains the rendered output for both test cases shown above. You won&rsquo;t ever need to manually edit this file - Jest will take care of that for you, as we are about to find out.</p>

<p>Let&rsquo;s make a change to the <code>BackstageHeader</code> component. Instead of using the FontAwesome right-angle-bracket between each header item, let&rsquo;s use the left-angle-bracket instead. We change the relevant line in <code>backstage_header.jsx</code> from <code>&lt;i className='fa fa-angle-right'/&gt;</code> to <code>&lt;i className='fa fa-angle-left'/&gt;</code>. Switching back to the shell where we ran the tests in watch mode previously, we see the following output:</p>

<pre><code> FAIL  tests/components/backstage/components/backstage_header.test.jsx
  ● components/backstage/components/BackstageHeader › should match snapshot with children

    expect(value).toMatchSnapshot()
    
    Received value does not match stored snapshot 1.
    
    - Snapshot
    + Received
    
    @@ -7,11 +7,11 @@
         &lt;/div&gt;
         &lt;span
           className=&quot;backstage-header__divider&quot;
         &gt;
           &lt;i
    -        className=&quot;fa fa-angle-right&quot;
    +        className=&quot;fa fa-angle-left&quot;
           /&gt;
         &lt;/span&gt;
         &lt;div&gt;
           Child 2
         &lt;/div&gt;
      
      at Object.&lt;anonymous&gt; (tests/components/backstage/components/backstage_header.test.jsx:24:25)
      at process._tickCallback (internal/process/next_tick.js:109:7)

  components/backstage/components/BackstageHeader
    ✓ should match snapshot without children (3ms)
    ✕ should match snapshot with children (5ms)

Snapshot Summary
 › 1 snapshot test failed in 1 test suite. Inspect your code changes or press `u` to update them.

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   1 failed, 1 passed, 2 total
Time:        1.896s
Ran all test suites related to changed files.

Watch Usage
 › Press a to run all tests.
 › Press u to update failing snapshots.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
</code></pre>

<p>In that output, you can see that one of the test cases has passed, but the other has failed, due to the change to the symbol displayed between the child components. Helpfully, a diff of the rendered output is displayed. By looking at the diff, we can see that the test case failing is due to our intentional change to <code>BackstageHeader</code>, so we should update the test snapshot, rather than fix a bug which the tests have brought to light. We can do this simply by pressing the letter <code>u</code>. Once this has completed, we see the following output indicating that the tests are now passing once more:</p>

<pre><code>PASS  tests/components/backstage/components/backstage_header.test.jsx
  components/backstage/components/BackstageHeader
    ✓ should match snapshot without children (4ms)
    ✓ should match snapshot with children (3ms)

Snapshot Summary
 › 1 snapshot updated in 1 test suite.

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   1 updated, 1 passed, 2 total
Time:        0.528s, estimated 2s
Ran all test suites related to changed files.

Watch Usage
 › Press a to run all tests.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
</code></pre>

<p>The contents of the <code>__snapshots__</code> directories are an essential part of the test suite. Be sure to always run the full test suite to generate them after adding or modifying any components or test code, and to include them in your git commits.</p>

<h3 id="global-state">Global State</h3>

<p>The <code>BackstageHeader</code> component is a very simple, pure component. But how about a more complex component? For this second example, we will use the <code>AboutBuildModal</code> component. The source code for this component is too long to reproduce in full, but can be seen <a href="https://github.com/mattermost/platform/blob/v3.8.2/webapp/components/about_build_modal.jsx">here</a>. The props it expects are as follows:</p>

<pre><code class="language-javascript">AboutBuildModal.propTypes = {
    show: React.PropTypes.bool.isRequired,
    onModalDismissed: React.PropTypes.func.isRequired
};
</code></pre>

<p>Testing how it renders with <code>show</code> set to <code>true</code> and <code>false</code> respectively would be simple enough, but by examining the source code of the component, we see that it also renders differently depending on some global state. In order to test this, we need test cases covering the full range of global state which can have an effect on how it renders. One example is shown below:</p>

<pre><code class="language-javascript">test('should show the build number if it is the different from the version number', () =&gt; {
    global.window.mm_config = {
        BuildEnterpriseReady: 'false',
        Version: '3.6.0',
        BuildNumber: '3.6.2',
        SQLDriverName: 'Postgres',
        BuildHash: 'abcdef1234567890',
        BuildDate: '21 January 2017'
    };

    global.window.mm_license = null;

    const wrapper = shallow(
        &lt;AboutBuildModal
            show={true}
            onModalDismissed={null}
        /&gt;
    );
    expect(wrapper.find('#versionString').text()).toBe(' 3.6.0\u00a0 (3.6.2)');
});
</code></pre>

<p>That&rsquo;s just one of the test cases needed to ensure the different ways in which the component can render are all covered. The full test suite for the <code>AboutBuildModal</code> can be seen <a href="https://github.com/mattermost/platform/blob/v3.8.2/webapp/tests/components/about_build_modal.test.jsx">here</a>.</p>

<h3 id="mounting-components">Mounting Components</h3>

<p>Continuing with the <code>AboutBuildModal</code>, there&rsquo;s one other prop we want to test: the <code>onModalDismissed</code> callback. This should be triggered when the <code>Modal</code> component within the <code>AboutBuildModal</code> is hidden. In order to interact with the full component hierarchy within the <code>AboutBuildModal</code>, we need to do a full render, or &ldquo;mount&rdquo;, rather than a shallow render as we&rsquo;ve been using previously. We can then use the <code>find()</code> method on the wrapper to locate the inner component and trigger it as if it has been hidden by the user, to test if our <code>onModalDismissed</code> prop is correctly called.</p>

<pre><code class="language-javascript">test('should call onModalDismissed callback when the modal is hidden', (done) =&gt; {
    global.window.mm_config = {
        BuildEnterpriseReady: 'false',
        Version: '3.6.0',
        BuildNumber: '3.6.2',
        SQLDriverName: 'Postgres',
        BuildHash: 'abcdef1234567890',
        BuildDate: '21 January 2017'
    };

    global.window.mm_license = null;

    function onHide() {
        done();
    }

    const wrapper = mountWithIntl(
        &lt;AboutBuildModal
            show={true}
            onModalDismissed={onHide}
        /&gt;
    );
    wrapper.find(Modal).first().props().onHide();
});
</code></pre>

<h3 id="react-i18n-test-helper">React i18n Test Helper</h3>

<p>If you were looking closely, you might have noticed that we used a function called <code>mountWithIntl()</code> in the previous test case. This is a custom function that wraps the <code>mount()</code> function provided by enzyme, in order to inject the props needed for React i18n support to work. Whenever you are shallow rendering or mounting a component which will result in the rendering of localised strings, you should use the appropriate wrapper functions to ensure they work correctly. The code is very simple and shown below (you can see it in the Mattermost source tree <a href="https://github.com/mattermost/platform/blob/v3.8.2/webapp/tests/helpers/intl-test-helper.jsx">here</a>).</p>

<pre><code class="language-javascript">import {mount, shallow} from 'enzyme';
import React from 'react';
import {IntlProvider, intlShape} from 'react-intl';

const intlProvider = new IntlProvider({locale: 'en'}, {});
const {intl} = intlProvider.getChildContext();

export function shallowWithIntl(node, {context} = {}) {
    return shallow(React.cloneElement(node, {intl}), {
        context: Object.assign({}, context, {intl})
    });
}

export function mountWithIntl(node, {context, childContextTypes} = {}) {
    return mount(React.cloneElement(node, {intl}), {
        context: Object.assign({}, context, {intl}),
        childContextTypes: Object.assign({}, {intl: intlShape}, childContextTypes)
    });
}
</code></pre>

<h3 id="testing-events">Testing events</h3>

<p>There&rsquo;s one other major feature of enzyme that we haven&rsquo;t shown in these examples: event simulation. Enzyme allows you to simulate events in order to test your event handlers. This can be done by finding the relevant item on the rendered <code>wrapper</code> object, then using the <code>simulate()</code> method to trigger an event, and using <code>toBeCalled()</code> to assert that the appropriate handler is called. The previous example test could thus be rewritten as follows:</p>

<pre><code class="language-javascript">test('should call onModalDismissed callback when the modal is hidden', () =&gt; {
    global.window.mm_config = {
        BuildEnterpriseReady: 'false',
        Version: '3.6.0',
        BuildNumber: '3.6.2',
        SQLDriverName: 'Postgres',
        BuildHash: 'abcdef1234567890',
        BuildDate: '21 January 2017'
    };

    const onHide = jest.fn();
    const wrapper = mountWithIntl(
        &lt;AboutBuildModal
            show={true}
            onModalDismissed={onHide}
        /&gt;
    );
    wrapper.find(Modal).first().simulate('hide');
    expect(onHide).toBeCalled();
});
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Component tests provide an easy way of unit testing React components, ensuring consistency in their rendered output, and enforcing a reliable, props-based API. As we move the web app codebase to Redux, the potential benefits increase dramatically, as almost all UI components will be fully testable in this way. Going forward, we expect to make component tests a requirement for all new (or refactored) UI components introduced into the Mattermost webapp in the near future, similar to how we already require test coverage for all server-side changes. You can keep see the Mattermost webapp&rsquo;s component tests as they are added <a href="https://github.com/mattermost/platform/tree/master/webapp/tests/components">here</a>.</p>

  </div>
  
</div>
</div>

  </body>
</html>
